name: CD Pipeline - EC2 Deployment

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ap-southeast-1
  ECR_BACKEND_REPOSITORY: tariffsheriff-backend
  ECR_FRONTEND_REPOSITORY: tariffsheriff-frontend

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Check for file changes
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            backend:
              - 'apps/backend/**'
              - '.github/workflows/cd.yml'
            frontend:
              - 'apps/frontend/**'
              - '.github/workflows/cd.yml'

  build-backend:
    name: Build Backend Docker Image
    runs-on: ubuntu-latest
    needs: [changes]
    if: needs.changes.outputs.backend == 'true'
    timeout-minutes: 20
    outputs:
      image: ${{ steps.image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'
      
      - name: Build JAR
        working-directory: apps/backend
        run: |
          echo "ðŸ“¦ Building backend JAR..."
          mvn -B clean package -DskipTests
          
          JAR_FILE=$(find target -name "*.jar" ! -name "*-original.jar" | head -n 1)
          if [ -z "$JAR_FILE" ]; then
            echo "âŒ JAR file not found!"
            exit 1
          fi
          echo "âœ… JAR built: $JAR_FILE"
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=latest
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: apps/backend
          file: apps/backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:buildcache
          cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:buildcache,mode=max
      
      - name: Set image output
        id: image
        run: |
          FULL_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ steps.meta.outputs.version }}"
          echo "image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "âœ… Using image: $FULL_IMAGE"

  build-frontend:
    name: Build Frontend Docker Image
    runs-on: ubuntu-latest
    needs: [changes]
    if: needs.changes.outputs.frontend == 'true'
    timeout-minutes: 20
    outputs:
      image: ${{ steps.image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=latest
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: apps/frontend
          file: apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:buildcache
          cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:buildcache,mode=max
      
      - name: Set image output
        id: image
        run: |
          FULL_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ steps.meta.outputs.version }}"
          echo "image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "âœ… Using image: $FULL_IMAGE"

  deploy-to-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    if: |
      always() && 
      (needs.build-backend.result == 'success' || needs.build-frontend.result == 'success')
    timeout-minutes: 10
    environment:
      name: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Add SSH config to disable strict host checking (for first-time connection)
          cat > ~/.ssh/config << EOF
          Host ${{ secrets.EC2_HOST }}
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ConnectTimeout 10
          EOF
          chmod 600 ~/.ssh/config
          
          echo "âœ… SSH configured"
      
      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          BACKEND_IMAGE: ${{ needs.build-backend.outputs.image || '' }}
          FRONTEND_IMAGE: ${{ needs.build-frontend.outputs.image || '' }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_USERNAME: ${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          echo "ðŸš€ Deploying to EC2..."
          
          # Create deployment script
          cat > /tmp/deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e
          
          echo "ðŸ“¥ Logging into ECR..."
          aws ecr get-login-password --region ap-southeast-1 | docker login --username AWS --password-stdin REGISTRY_PLACEHOLDER
          
          # Deploy backend if image is provided
          if [ -n "BACKEND_IMAGE_PLACEHOLDER" ] && [ "BACKEND_IMAGE_PLACEHOLDER" != "" ]; then
            echo "ðŸ”„ Deploying backend..."
            docker pull BACKEND_IMAGE_PLACEHOLDER
            docker stop tariffsheriff-backend 2>/dev/null || true
            docker rm tariffsheriff-backend 2>/dev/null || true
            docker run -d \
              --name tariffsheriff-backend \
              --restart unless-stopped \
              -p 8080:8080 \
              -e SPRING_PROFILES_ACTIVE=prod \
              -e DATABASE_URL="DATABASE_URL_PLACEHOLDER" \
              -e DATABASE_USERNAME="DATABASE_USERNAME_PLACEHOLDER" \
              -e DATABASE_PASSWORD="DATABASE_PASSWORD_PLACEHOLDER" \
              -e JWT_SECRET="JWT_SECRET_PLACEHOLDER" \
              BACKEND_IMAGE_PLACEHOLDER
            echo "âœ… Backend deployed"
          fi
          
          # Deploy frontend if image is provided
          if [ -n "FRONTEND_IMAGE_PLACEHOLDER" ] && [ "FRONTEND_IMAGE_PLACEHOLDER" != "" ]; then
            echo "ðŸ”„ Deploying frontend..."
            docker pull FRONTEND_IMAGE_PLACEHOLDER
            docker stop tariffsheriff-frontend 2>/dev/null || true
            docker rm tariffsheriff-frontend 2>/dev/null || true
            docker run -d \
              --name tariffsheriff-frontend \
              --restart unless-stopped \
              -p 80:80 \
              FRONTEND_IMAGE_PLACEHOLDER
            echo "âœ… Frontend deployed"
          fi
          
          echo "ðŸ§¹ Cleaning up old images..."
          docker image prune -af --filter "until=24h" || true
          
          echo "âœ… Deployment complete!"
          docker ps --filter "name=tariffsheriff"
          DEPLOY_SCRIPT
          
          # Replace placeholders with actual values
          sed -i "s|REGISTRY_PLACEHOLDER|$ECR_REGISTRY|g" /tmp/deploy.sh
          sed -i "s|BACKEND_IMAGE_PLACEHOLDER|$BACKEND_IMAGE|g" /tmp/deploy.sh
          sed -i "s|FRONTEND_IMAGE_PLACEHOLDER|$FRONTEND_IMAGE|g" /tmp/deploy.sh
          sed -i "s|DATABASE_URL_PLACEHOLDER|$DATABASE_URL|g" /tmp/deploy.sh
          sed -i "s|DATABASE_USERNAME_PLACEHOLDER|$DATABASE_USERNAME|g" /tmp/deploy.sh
          sed -i "s|DATABASE_PASSWORD_PLACEHOLDER|$DATABASE_PASSWORD|g" /tmp/deploy.sh
          sed -i "s|JWT_SECRET_PLACEHOLDER|$JWT_SECRET|g" /tmp/deploy.sh
          
          # Copy and execute deployment script
          scp -i ~/.ssh/deploy_key /tmp/deploy.sh $EC2_USER@$EC2_HOST:/tmp/deploy.sh
          ssh -i ~/.ssh/deploy_key $EC2_USER@$EC2_HOST "chmod +x /tmp/deploy.sh && bash /tmp/deploy.sh"
          
          echo "âœ… Deployment successful!"
      
      - name: Verify deployment
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          echo "ðŸ” Checking container status..."
          ssh -i ~/.ssh/deploy_key $EC2_USER@$EC2_HOST "docker ps --filter 'name=tariffsheriff' --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'"

  health-check:
    name: Post-Deployment Health Check
    runs-on: ubuntu-latest
    needs: [deploy-to-ec2]
    if: needs.deploy-to-ec2.result == 'success'
    timeout-minutes: 5
    steps:
      - name: Check backend health
        continue-on-error: true
        run: |
          echo "ðŸ¥ Checking backend health..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s http://${{ secrets.EC2_HOST }}:8080/actuator/health > /dev/null 2>&1; then
              echo "âœ… Backend is healthy!"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "â³ Attempt $RETRY_COUNT/$MAX_RETRIES failed, retrying in 10s..."
            sleep 10
          done
          
          echo "âš ï¸  Backend health check failed after $MAX_RETRIES attempts"
      
      - name: Check frontend health
        continue-on-error: true
        run: |
          echo "ðŸ¥ Checking frontend health..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s http://${{ secrets.EC2_HOST }} > /dev/null 2>&1; then
              echo "âœ… Frontend is healthy!"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "â³ Attempt $RETRY_COUNT/$MAX_RETRIES failed, retrying in 10s..."
            sleep 10
          done
          
          echo "âš ï¸  Frontend health check failed after $MAX_RETRIES attempts"

  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-to-ec2, health-check]
    if: always()
    timeout-minutes: 5
    steps:
      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment:** ${{ needs.deploy-to-ec2.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health Check:** ${{ needs.health-check.result }}" >> $GITHUB_STEP_SUMMARY
